%module(docstring="C++ backend for @DATATYPE@ matrices") pairinteraction_@DATATYPE@

%{
#define SWIG_FILE_WITH_INIT
#include "pyutils.h"
#include "dtypes.h"
#include "Interface.h"
#include "State.h"
#include "SystemOne.h"
#include "SystemTwo.h"
%}


%init %{
import_array();
%}


%feature("autodoc", "3");


%include "attribute.i"
%include "exception.i"
%include "std_array.i"
%include "std_complex.i"
%include "std_string.i"
%include "std_vector.i"
%include "std_set.i"


// Convert C++ exceptions to Python exceptions
// http://www.swig.org/Doc1.3/Library.html#Library_stl_exceptions
%exception {
  try {
    $action
  } catch (const std::exception& e) {
    SWIG_exception(SWIG_RuntimeError, e.what());
  }
}


// Wrap the << operator
// http://stackoverflow.com/questions/2548779/how-to-stringfy-a-swig-matrix-object-in-python
%define __STR__()
std::string __str__() {
  std::ostringstream out;
  out << *$self;
  return out.str();
}
%enddef


// Instantiate often used STL templates
namespace std {
  %template(ArrayStringTwo) array<string,2>;
  %template(ArrayIntTwo) array<int,2>;
  %template(ArrayFloatTwo) array<float,2>;
  %template(ArrayDoubleTwo) array<double,3>;
  %template(VectorInt) vector<int>;
  %template(VectorDouble) vector<double>;
  %template(VectorFloat) vector<float>;
  %template(VectorStateOne) vector<StateOne>;
  %template(VectorStateTwo) vector<StateTwo>;
  %template(VectorSizeT) vector<size_t>;
  %template(VectorComplexDouble) vector<std::complex<double>>;
  %template(SetInt) set<int>;
};


// Load numpy wrappers
%include "pyutils.h"


%include "eigen.i"


%rename(__lt__) operator<;
%include "dtypes.h"


%include "Interface.h"


// Wrap State.h
%ignore hash;
%rename(__ostream__) operator<<;
%include "State.h"


%attribute(StateOne, double, energy, getEnergy);
%extend StateOne {
  __STR__();
};


%attribute(StateTwo, double, energy, getEnergy);
%extend StateTwo {
  __STR__();
};


// Wrap SystemBase.h
%include "SystemBase.h"

// SWIG extensions for SciPy interoperability // TODO avoide code duplication for getCoefficients and getHamiltonianmatrix ~~> define a macro?
%extend SystemBase {
void _compressCoefficients()
{
    if ( ! $self->getCoefficients().isCompressed() )
        $self->getCoefficients().makeCompressed();
}
size_t _getCoefficientsNumrows() {
    return $self->getCoefficients().rows();
}
size_t _getCoefficientsNumcols() {
    return $self->getCoefficients().cols();
}
numpy::array _getCoefficientsIndptr() {
    return numpy::view($self->getCoefficients().outerIndexPtr(),
                       $self->getCoefficients().outerIndexPtr() + $self->getCoefficients().outerSize() + 1);
}
numpy::array _getCoefficientsIndices() {
    return numpy::view($self->getCoefficients().innerIndexPtr(),
                       $self->getCoefficients().innerIndexPtr() + $self->getCoefficients().nonZeros());
}
numpy::array _getCoefficientsData() {
    return numpy::view($self->getCoefficients().valuePtr(),
                       $self->getCoefficients().valuePtr() + $self->getCoefficients().nonZeros());
}
void _compressHamiltonianmatrix()
{
    if ( ! $self->getHamiltonianmatrix().isCompressed() )
        $self->getHamiltonianmatrix().makeCompressed();
}
size_t _getHamiltonianmatrixNumrows() {
    return $self->getHamiltonianmatrix().rows();
}
size_t _getHamiltonianmatrixNumcols() {
    return $self->getHamiltonianmatrix().cols();
}
numpy::array _getHamiltonianmatrixIndptr() {
    return numpy::view($self->getHamiltonianmatrix().outerIndexPtr(),
                       $self->getHamiltonianmatrix().outerIndexPtr() + $self->getHamiltonianmatrix().outerSize() + 1);
}
numpy::array _getHamiltonianmatrixIndices() {
    return numpy::view($self->getHamiltonianmatrix().innerIndexPtr(),
                       $self->getHamiltonianmatrix().innerIndexPtr() + $self->getHamiltonianmatrix().nonZeros());
}
numpy::array _getHamiltonianmatrixData() {
    return numpy::view($self->getHamiltonianmatrix().valuePtr(),
                       $self->getHamiltonianmatrix().valuePtr() + $self->getHamiltonianmatrix().nonZeros());
}
}


// Wrap SystemOne.h and SystemTwo.h
%template(_SystemStateOne) SystemBase<StateOne>;
%template(_SystemStateTwo) SystemBase<StateTwo>;
%include "SystemOne.h"
%include "SystemTwo.h"

%attribute(SystemOne, std::vector<StateOne>&, states  , getStates  );
%attribute(SystemTwo, std::vector<StateTwo>&, states  , getStates  );


// Python specific extensions

// This block has to be the last in the Interface.i file, because it
// will be copied literally into the Python module and we want to
// overwrite specific methods, defined before.

%pythoncode %{

# TODO use GHz in the C++ backend so that the conversion is not
# necessary
au2GHz = 6579683.920711

from scipy.sparse import csc_matrix
import numpy as np

def getCoefficients (self):
    self._compressCoefficients()
    num_rows = self._getCoefficientsNumrows()
    num_cols = self._getCoefficientsNumcols()
    indptr = self._getCoefficientsIndptr()
    indices = self._getCoefficientsIndices()
    data = self._getCoefficientsData()
    return csc_matrix((data, indices, indptr), shape=(num_rows, num_cols))

def getHamiltonianmatrix (self):
    self._compressHamiltonianmatrix()
    num_rows = self._getHamiltonianmatrixNumrows()
    num_cols = self._getHamiltonianmatrixNumcols()
    indptr = self._getHamiltonianmatrixIndptr()
    indices = self._getHamiltonianmatrixIndices()
    data = self._getHamiltonianmatrixData()
    return csc_matrix((data, indices, indptr), shape=(num_rows, num_cols))

class vector_to_numpy:
    def __init__(self, method):
        self.method = method

    def __call__(self, *args):
        return np.array( self.method(*args) )

class numpy_to_vector:
    def __init__(self, method, *args):
        self.method = method
        self.args   = args

    def __call__(self, ndarray):
        dtype = ndarray.dtype
        size = len(ndarray)

        # Decide datatype
        if np.issubdtype(dtype, np.float):
            v = VectorDouble(size)
        elif np.issubdtype(dtype, np.complex):
            v = VectorComplexDouble(size)
        else:
            raise TypeError("Unhandled type {}".format(dtype))

        # Copy over data
        v[:] = ndarray[:]

        # Hand over to method
        self.method(v,*self.args)

SystemOne.coefficients = property(getCoefficients)
SystemTwo.coefficients = property(getCoefficients)
SystemOne.hamiltonianmatrix = property(getHamiltonianmatrix)
SystemTwo.hamiltonianmatrix = property(getHamiltonianmatrix)
SystemOne.diagonal = property(SystemOne.getDiagonal)
SystemTwo.diagonal = property(SystemTwo.getDiagonal)

%}
