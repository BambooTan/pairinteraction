%module(docstring="C++ backend for @DATATYPE@ matrices") pairinteraction_@DATATYPE@

%{
#include "Interface.h"
#include "State.h"
#include "Basis.h"
%}


%feature("autodoc", "3");


%include "exception.i"
%include "std_array.i"
%include "std_complex.i"
%include "std_string.i"
%include "std_vector.i"


// Convert C++ exceptions to Python exceptions
// http://www.swig.org/Doc1.3/Library.html#Library_stl_exceptions
%exception {
  try {
    $action
  } catch (const std::exception& e) {
    SWIG_exception(SWIG_RuntimeError, e.what());
  }
}


// Wrap the << operator
// http://stackoverflow.com/questions/2548779/how-to-stringfy-a-swig-matrix-object-in-python
%define __STR__()
std::string __str__() {
  std::ostringstream out;
  out << *$self;
  return out.str();
}
%enddef


// Instantiate often used STL templates
namespace std {
  %template(ArrayStringTwo) array<string,2>;
  %template(ArrayIntTwo) array<int,2>;
  %template(VectorInt) vector<int>;
  %template(VectorDouble) vector<double>;
  %template(VectorStateOne) vector<StateOne>;
  %template(VectorStateTwo) vector<StateTwo>;
  %template(VectorSizeT) vector<size_t>;
  %template(VectorComplexDouble) vector<std::complex<double>>;
};


%include "Interface.h"


// Wrap State.h
%ignore hash;
%ignore operator<<;
%include "State.h"

%extend StateOne {
  __STR__();
  %pythoncode %{
      __swig_getmethods__["element"] = getElement
      __swig_setmethods__["element"] = setElement
      __swig_getmethods__["n"] = getN
      __swig_setmethods__["n"] = setN
      __swig_getmethods__["l"] = getL
      __swig_setmethods__["l"] = setL
      __swig_getmethods__["j"] = getJ
      __swig_setmethods__["j"] = setJ
      __swig_getmethods__["m"] = getM
      __swig_setmethods__["m"] = setM
      if _newclass:
          element = property(getElement, setElement)
          n = property(getN, setN)
          l = property(getL, setL)
          j = property(getJ, setJ)
          m = property(getM, setM)
  %}
};
%extend StateTwo {
  __STR__();
  %pythoncode %{
      __swig_getmethods__["element"] = getElement
      __swig_setmethods__["element"] = setElement
      __swig_getmethods__["n"] = getN
      __swig_setmethods__["n"] = setN
      __swig_getmethods__["l"] = getL
      __swig_setmethods__["l"] = setL
      __swig_getmethods__["j"] = getJ
      __swig_setmethods__["j"] = setJ
      __swig_getmethods__["m"] = getM
      __swig_setmethods__["m"] = setM
      if _newclass:
          element = property(getElement, setElement)
          n = property(getN, setN)
          l = property(getL, setL)
          j = property(getJ, setJ)
          m = property(getM, setM)
  %}
};


// Wrap Basis.h
%include "BasisBase.h"
%template(BasisStateOne) Basis<StateOne>;
%template(BasisStateTwo) Basis<StateTwo>;
%include "Basis.h"


%pythoncode %{

from scipy.sparse import csc_matrix
import numpy as np
def getCoefficients (self):
    num_rows = self._getCoefficientsNumrows()
    num_cols = self._getCoefficientsNumcols()
    indptr = self._getCoefficientsIndptr()
    indices = self._getCoefficientsIndices()
    data = self._getCoefficientsData()
    return csc_matrix((data, indices, indptr), shape=(num_rows, num_cols)) # TODO copy=False

BasisOne.getCoefficients = getCoefficients
BasisTwo.getCoefficients = getCoefficients

%}
